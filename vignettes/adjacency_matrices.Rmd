---
title: "Adjacency matrices"
output:
    BiocStyle::html_document:
        toc: true
        toc_float: true
        toc_depth: 2
        number_sections: true
vignette: >
  %\VignetteIndexEntry{3. Working with (bi)adjacency matrices}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(anansi)
library(ggplot2)
```

# Introduction
A common challenge in integrative analysis of high-dimensional data sets is 
subsequent biological interpretation. Anansi addresses this challenge by only 
considering pairwise associations that are known to occur *a priori*. In order
to achieve this, we need to provide this relational information to anansi in the
form of a (bi)adjacency matrix. In this vignette, we provide some intuition on 
(bi)adjacency and demonstrate how to provide custom relational information to 
anansi. 

# Understanding adjacency matrices

## Example from Biology: The Krebs cycle


```{r plot_krebs, echo=FALSE, fig.width=6, fig.height=6, fig.align="center", fig.cap="A simplified representation of the krebs cycle."}

kd <- data.frame(
  enzyme = c("Isocitrate\ndehydrogenase", "Aconitase", "Aconitase",  
            "Citrate\ndehydrogenase", "Malate\ndehydrogenase", "Fumarase",  
            "Succinate\ndehydrogenase","Succinyl-CoA\nsynthetase",
            "α-Ketoglutarate\ndehydrogenase"), 
  metab = c("Isocitrate","cis-Aconitate","Citrate","Oxaloacetate","L-Malate",
             "Fumarate","Succinate","Succinyl-CoA", "α-Ketoglutarate"),
           rad = seq(0, 2*pi * 8/9, length.out = 9)) 

ggplot(kd) + 
  annotate("path",
           x=0.75*cos(seq(0,2*pi,length.out=100)),
           y=0.75*sin(seq(0,2*pi,length.out=100))) +

  geom_tile(aes(x = 0.8*cos(rad), y =0.8* sin(rad)), width = 0.45, height = 0.15, 
            fill = "orange", color = "black", show.legend = FALSE) + 
  geom_text(aes(x = 0.8*cos(rad), y =0.8* sin(rad), label = metab), size = 3,
                show.legend = FALSE) + 
  
  geom_segment(aes(x = 0.75*cos(rad - pi/9), y =0.75* sin(rad - pi/9), 
                   xend = cos(rad - pi/9), yend =sin(rad - pi/9))) +
  
  geom_point(aes(x = 0.75*cos(rad-pi/9), y =0.75* sin(rad-pi/9)), size = 3, 
            fill = "dodgerblue", color = "black", show.legend = FALSE, 
            shape = 21) + 
  geom_text(aes(x = 1.2*cos(rad-pi/9), y =1.2* sin(rad-pi/9),label = enzyme), 
            size = 3, show.legend = FALSE) + 
  
  scale_y_continuous(limits = c(-1.5, 1.5)) +
  scale_x_continuous(limits = c(-1.5, 1.5)) +
  
  theme_void()

  

```

### notes to be expanded
All-vs-all analysis looks like two columns of length c(8, 9), all vs all -> 72 
comparisons. 

In most cases, only a subset of these comparisons is scientifically relevant to
investigate. The others actively harms statistical power, as they these 
comparisons will never be interpreted, but their p-values will still be tallied 
for the purpose of FDR and FWER. 


# Defining an adjacency matrix
There are numerous ways in which we can define an adjacency matrix. Here, we 
demonstrate a graph-based and matrix based approach.

```{r init_list, echo=FALSE}
krebs_edge_df <- data.frame(
 Enzyme = c("Aconitase", "Aconitase", "Citrate synthase", 
"Fumarase", "Succinate dehydrogenase", "Aconitase", "Isocitrate dehydrogenase", 
"Fumarase", "Malate dehydrogenase", "Citrate synthase", "Malate dehydrogenase", 
"Succinate dehydrogenase", "Succinyl-CoA synthetase", "Succinyl-CoA synthetase", 
"transsuccinytase", "α-Ketoglutarate dehydrogenase", "Isocitrate dehydrogenase", 
"transsuccinytase", "α-Ketoglutarate dehydrogenase"), 
 Metabolite = c("cis-Aconitate", 
"Citrate", "Citrate", "Fumarate", "Fumarate", "Isocitrate", "Isocitrate", 
"L-Malate", "L-Malate", "Oxaloacetate", "Oxaloacetate", "Succinate", 
"Succinate", "Succinyl-CoA", "Succinyl-CoA", "Succinyl-CoA", 
"α-Ketoglutarate", "α-Ketoglutarate", "α-Ketoglutarate"))
```

## The graph approach
Importantly, (bi)adjacency matrices can be understood as graphs. Two common 
packages that deal with graphs are [`igraph`](https://r.igraph.org/) and [`graph`](https://bioconductor.org/packages/graph/). 
```{r igraph_1, message=FALSE}
library(igraph)

# Convert data.frame to graph
g <- graph_from_data_frame(krebs_edge_df, directed = FALSE)

```

Now that we have constructed a graph, we still need to identify which features, 
vertices, belong to which data modality, in this case either enzymes and 
metabolites. `igraph` does this using a boolean vector, where `TRUE` values 
become columns, which corresponds to `tableX`, whereas `FALSE` values become 
rows, corresponding to `tableY`.

```{r igraph_2, message=FALSE}
V(g)$type <- V(g)$name %in% krebs_edge_df$Metabolite

# Now that we've defined type, we can convert to biadjacency matrix: 
bi_mat1 <- as_biadjacency_matrix(g)

head(bi_mat1, n = c(4, 4))
```
Though biadjacency support in `graph` is currently limited, We note that igraph 
and graph objects can be converted using the `graph_from_graphnel()` and 
`as_graphnel()` functions in `igraph`.

## The matrix approach
We can also define a matrix directly. Conveniently, sparse matrices can be 
defined easily from our starting data. The `Matrix` library provides fantastic 
support for this.
```{r Matrix, message=FALSE}
library(Matrix)

# For this approach, it's useful to prepare the input as two factors:
enzymes     <- factor(krebs_edge_df$Enzyme)
metabolites <- factor(krebs_edge_df$Metabolite)

# We can get integers out of factors, corresponding to their level indices 
bi_mat2 <- sparseMatrix(i = as.integer(enzymes), 
             j = as.integer(metabolites), 
             dimnames = list(
               levels(enzymes),
               levels(metabolites)
               )
             )

head(bi_mat2, n = c(4, 4))

```

# Session info

```{r}
sessionInfo()
```
